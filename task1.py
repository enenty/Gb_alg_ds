"""
Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех уроков.
Проанализировать результат и определить программы с наиболее эффективным использованием памяти.

выбрать хорошую задачу, которую имеет смысл оценивать по памяти;

написать 3 варианта кода (один у вас уже есть);

проанализировать 3 варианта и выбрать оптимальный;

результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с кодом.
Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;

написать общий вывод: какой из трёх вариантов лучше и почему.
"""
import sys
from collections import deque


def get_size_sum(vars, size_sum=0):
    for var, obj in vars:
        size_sum += sys.getsizeof(obj)
        print(var, type(obj), sys.getsizeof(obj))
    print(f'Общее количество занятой памяти: {size_sum}')

# Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран.
# Например, если введено число 3486, надо вывести 6843

############################## 1 вариант ##############################


def reverse(num, rev_string=''):
    print(f'Изначально переменная {num=} хранит {sys.getsizeof(num)}')
    def reverse_num(num):
        nonlocal rev_string
        if int(num) < 10:
            rev_string += str(num)
            # return rev_string
            return locals().items()
        else:
            last_dig = int(num) % 10
            rev_string += str(last_dig)
            num = int(num) // 10
            return reverse_num(num)

    return reverse_num(num)


#
#
# print(reverse(input('Введите целое число: ')))


############################## 2 вариант ##############################

def reverse_deque(num):
    print(f'Изначально переменная {num=} хранит {sys.getsizeof(num)}')
    num_deque = deque(num)
    num_deque.reverse()
    # return f"{''.join(list(num))}"
    return locals().items()


#
#
# print(reverse_deque(input('Введите целое число: ')))

############################## 3 вариант ##############################


def reverse_int(num):
    print(f'Изначально переменная {num=} хранит {sys.getsizeof(num)}')
    num = int(num)
    rev_num = 0
    while num > 0:
        rev_num *= 10
        rev_num += num % 10
        num = num // 10
    # return rev_num
    return locals().items()


# print(reverse_int(int(input('Введите целое число: '))))
vars1 = reverse(input('Введите целое число: '))
get_size_sum(vars1)
print('--------------------')
vars2 = reverse_deque(input('Введите целое число: '))
get_size_sum(vars2)
print('--------------------')
vars3 = reverse_int(input('Введите целое число: '))
get_size_sum(vars3)

print(sys.maxsize)

################################################### Вывод ######################################################

# Из-за специфики алгоритмов выполнения данной программы, количество байт, которое хранится в переменных
# в вариантах 1 и 3 изменятся динамически: при прохождении цикла, изначальное значение переменной num сокращается.
# Не уверен, стоит ли учитывать это или важен конечный результат на момент завершения выполнения алгоритмов.
# Несмотря на то, что вариант с использованием коллекции deque работает быстрее, он резервирует большое количество
# минимальной памяти, даже если в deque хранится всего 1 элемент.
# Рекурсивный алгоритм 1 варианта так же занимает больше памяти, чем алгоритм с простым циклом.
# Самым удачным по количеству зарезервированной памяти является 3 вариант.
#
#    Python 3.8.4 ----- 32bit
#
# Введите целое число: 12345
# Изначально переменная num='12345' хранит 30
# num <class 'int'> 14
# rev_string <class 'str'> 30
# reverse_num <class 'function'> 68
# Общее количество занятой памяти: 112
# --------------------
# Введите целое число: 12345
# Изначально переменная num='12345' хранит 30
# num <class 'collections.deque'> 312
# Общее количество занятой памяти: 312
# --------------------
# Введите целое число: 12345
# Изначально переменная num='12345' хранит 30
# num <class 'int'> 12
# rev_num <class 'int'> 16
# Общее количество занятой памяти: 28

